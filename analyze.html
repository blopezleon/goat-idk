<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Speech Analysis - AI Speech Therapist</title>
   <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">
   <style>
       body {
           font-family: 'Poppins', sans-serif;
           margin: 0;
           padding: 0;
           background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
           min-height: 100vh;
       }


       .container {
           max-width: 800px;
           margin: 0 auto;
           padding: 2rem;
       }


       .analysis-section {
           background: white;
           padding: 2rem;
           border-radius: 10px;
           box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
           margin-bottom: 2rem;
       }


       .record-button {
           display: inline-block;
           padding: 1rem 2rem;
           background-color: #3498db;
           color: white;
           border: none;
           border-radius: 30px;
           font-weight: 500;
           cursor: pointer;
           transition: all 0.3s ease;
       }


       .record-button:hover {
           background-color: #2980b9;
       }


       .record-button.recording {
           background-color: #e74c3c;
       }


       #transcription, #feedback {
           margin-top: 1rem;
           padding: 1rem;
           background: #f8f9fa;
           border-radius: 5px;
           min-height: 100px;
       }


       .status {
           color: #7f8c8d;
           margin-top: 0.5rem;
       }


       .button-group {
           display: flex;
           gap: 1rem;
           margin-bottom: 1rem;
       }


       .play-button {
           display: inline-block;
           padding: 1rem 2rem;
           background-color: #27ae60;
           color: white;
           border: none;
           border-radius: 30px;
           font-weight: 500;
           cursor: pointer;
           transition: all 0.3s ease;
       }


       .play-button:hover {
           background-color: #219a52;
       }


       .play-button:disabled {
           background-color: #bdc3c7;
           cursor: not-allowed;
       }


       .audio-player {
           margin-top: 1rem;
           width: 100%;
       }
   </style>
</head>
<body>
   <div class="container">
       <div class="analysis-section">
           <h2>Speech Analysis</h2>
           
           <h3>Practice Tongue Twisters</h3>
           <button id="tongueTwisterButton" class="record-button">Generate Tongue Twister</button>
           <div id="tongueTwisterDisplay" style="margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 5px;">
               Click the button to get a tongue twister...
           </div>

           <div class="button-group" style="margin-top: 2rem;">
               <button id="recordButton" class="record-button">Start Recording</button>
               <button id="playButton" class="play-button" disabled>Play Recording</button>
           </div>
           <p class="status" id="status">Click to start recording</p>
          
           <audio id="audioPlayback" class="audio-player" controls style="display: none;"></audio>
          
           <h3>Your Speech</h3>
           <div id="transcription">Transcription will appear here...</div>
          
           <h3>AI Feedback</h3>
           <div id="feedback">Feedback will appear here...</div>

           <div class="analysis-section">
               <h3>Raw Analysis Data</h3>
               <pre id="rawData" style="background: #f8f9fa; padding: 1rem; border-radius: 5px; overflow-x: auto;">
                   Raw data will appear here...
               </pre>
           </div>
       </div>
   </div>


   <script>
       let mediaRecorder;
       let audioChunks = [];
       let audioUrl;
      
       const recordButton = document.getElementById('recordButton');
       const playButton = document.getElementById('playButton');
       const status = document.getElementById('status');
       const audioPlayback = document.getElementById('audioPlayback');
       const transcriptionDiv = document.getElementById('transcription');
       const feedbackDiv = document.getElementById('feedback');


       recordButton.addEventListener('click', async () => {
           if (mediaRecorder && mediaRecorder.state === 'recording') {
               mediaRecorder.stop();
               recordButton.textContent = 'Start Recording';
               recordButton.classList.remove('recording');
           } else {
               try {
                   const stream = await navigator.mediaDevices.getUserMedia({
                       audio: {
                           channelCount: 1,
                           sampleRate: 16000
                       }
                   });
                   
                   audioChunks = [];
                   
                   mediaRecorder = new MediaRecorder(stream, {
                       mimeType: 'audio/webm'  // Record in WebM format first
                   });
                   
                   mediaRecorder.ondataavailable = (event) => {
                       if (event.data.size > 0) {
                           audioChunks.push(event.data);
                           console.log('Chunk received:', event.data.size);
                       }
                   };

                   mediaRecorder.onstop = () => {
                       // Create the WebM blob
                       const webmBlob = new Blob(audioChunks, { type: 'audio/webm' });
                       console.log('WebM blob created, size:', webmBlob.size);
                       
                       // Create URL for playback
                       if (audioUrl) {
                           URL.revokeObjectURL(audioUrl);
                       }
                       audioUrl = URL.createObjectURL(webmBlob);
                       
                       // Set up audio playback
                       audioPlayback.src = audioUrl;
                       audioPlayback.style.display = 'block';
                       playButton.disabled = false;

                       // Convert WebM to WAV
                       const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                       const fileReader = new FileReader();

                       fileReader.onloadend = () => {
                           const arrayBuffer = fileReader.result;
                           audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
                               // Convert to WAV
                               const wavBuffer = audioBufferToWav(audioBuffer);
                               const wavBlob = new Blob([wavBuffer], { type: 'audio/wav' });
                               
                               // Send WAV to server
                               const formData = new FormData();
                               formData.append('audio', wavBlob, 'recording.wav');
                               
                               fetch('http://127.0.0.1:3000/api/analyze-speech', {
                                   method: 'POST',
                                   body: formData
                               })
                               .then(response => response.json())
                               .then(results => {
                                   console.log('Server response:', results);
                                   
                                   // Display transcription
                                   transcriptionDiv.textContent = results.transcription || 'No transcription';
                                   
                                   // Display detailed scores
                                   let feedbackHtml = '<h3>Overall Scores:</h3>';
                                   feedbackHtml += `<p>Pronunciation: ${results.overallScore.PronScore}</p>`;
                                   feedbackHtml += `<p>Accuracy: ${results.overallScore.AccuracyScore}</p>`;
                                   feedbackHtml += `<p>Fluency: ${results.overallScore.FluencyScore}</p>`;
                                   feedbackHtml += `<p>Completeness: ${results.overallScore.CompletenessScore}</p>`;
                                   
                                   feedbackHtml += '<h3>Word-by-Word Scores:</h3>';
                                   feedbackHtml += '<table border="1"><tr><th>Word</th><th>Pronunciation</th><th>Accuracy</th><th>Fluency</th><th>Completeness</th><th>Prosody</th></tr>';
                                   
                                   results.wordScores.forEach(score => {
                                       feedbackHtml += `<tr>
                                           <td>${score.word}</td>
                                           <td>${score.pronunciation}</td>
                                           <td>${score.accuracy}</td>
                                           <td>${score.fluency}</td>
                                           <td>${score.completeness}</td>
                                           <td>${score.prosody}</td>
                                       </tr>`;
                                   });
                                   
                                   feedbackHtml += '</table>';
                                   feedbackDiv.innerHTML = feedbackHtml;
                                   
                                   status.textContent = 'Analysis complete';

                                   // Display raw data
                                   document.getElementById('rawData').textContent = JSON.stringify(results, null, 2);
                               })
                               .catch(error => {
                                   console.error('Server error:', error);
                                   status.textContent = 'Server error: ' + error.message;
                               });
                           });
                       };

                       fileReader.readAsArrayBuffer(webmBlob);
                   };

                   mediaRecorder.start(100);
                   recordButton.textContent = 'Stop Recording';
                   recordButton.classList.add('recording');
                   status.textContent = 'Recording...';

               } catch (error) {
                   console.error('Recording error:', error);
                   status.textContent = 'Error: ' + error.message;
               }
           }
       });

       // Tongue twister functionality
       const tongueTwisters = [
           "The red robot runs rapidly down the road",
            "She sells seashells by the seashore",
            "The big brown bear bought blueberries",
            "Charlie chews crunchy chocolate chips",
            "Thirty-three thirsty thieves thought thoughtfully",
            "The zebra zoomed past the buzzing bees",
            "I like vanilla ice cream with very vibrant flavors",
            "Please place the purple pen on the paper",
            "Tom took ten tiny turtles to the pond",
            "The quick fox jumped over the lazy dog"
       ];

       let currentTongueTwister = "";
       const tongueTwisterButton = document.getElementById('tongueTwisterButton');
       const tongueTwisterDisplay = document.getElementById('tongueTwisterDisplay');

       tongueTwisterButton.addEventListener('click', () => {
           currentTongueTwister = tongueTwisters[Math.floor(Math.random() * tongueTwisters.length)];
           tongueTwisterDisplay.textContent = currentTongueTwister;
           
           // Send the new reference text to the server
           fetch('http://127.0.0.1:3000/api/set-reference', {
               method: 'POST',
               headers: {
                   'Content-Type': 'application/json',
               },
               body: JSON.stringify({ referenceText: currentTongueTwister })
           })
           .catch(error => console.error('Error setting reference text:', error));
       });

       playButton.onclick = () => {
           if (audioPlayback.paused) {
               audioPlayback.play();
               playButton.textContent = 'Pause';
           } else {
               audioPlayback.pause();
               playButton.textContent = 'Play Recording';
           }
       };

       audioPlayback.onended = () => {
           playButton.textContent = 'Play Recording';
       };
   </script>

   <script>
       // Helper function to convert AudioBuffer to WAV format
       function audioBufferToWav(buffer) {
           const numChannels = buffer.numberOfChannels;
           const sampleRate = buffer.sampleRate;
           const format = 1; // PCM
           const bitDepth = 16;
           
           const bytesPerSample = bitDepth / 8;
           const blockAlign = numChannels * bytesPerSample;
           
           const wav = new ArrayBuffer(44 + buffer.length * bytesPerSample);
           const view = new DataView(wav);
           
           // Write WAV header
           writeString(view, 0, 'RIFF');
           view.setUint32(4, 36 + buffer.length * bytesPerSample, true);
           writeString(view, 8, 'WAVE');
           writeString(view, 12, 'fmt ');
           view.setUint32(16, 16, true);
           view.setUint16(20, format, true);
           view.setUint16(22, numChannels, true);
           view.setUint32(24, sampleRate, true);
           view.setUint32(28, sampleRate * blockAlign, true);
           view.setUint16(32, blockAlign, true);
           view.setUint16(34, bitDepth, true);
           writeString(view, 36, 'data');
           view.setUint32(40, buffer.length * bytesPerSample, true);
           
           // Write audio data
           const offset = 44;
           const data = new Float32Array(buffer.length);
           buffer.copyFromChannel(data, 0);
           
           for (let i = 0; i < data.length; i++) {
               const sample = Math.max(-1, Math.min(1, data[i]));
               view.setInt16(offset + i * bytesPerSample, sample * 0x7FFF, true);
           }
           
           return wav;
       }

       function writeString(view, offset, string) {
           for (let i = 0; i < string.length; i++) {
               view.setUint8(offset + i, string.charCodeAt(i));
           }
       }
   </script>
</body>
</html>
